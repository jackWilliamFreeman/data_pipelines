CREATE STORAGE INTEGRATION SNOWFLAKE_AWS_ACCESS
  TYPE = EXTERNAL_STAGE
  STORAGE_PROVIDER = 'S3'
  ENABLED = TRUE
  STORAGE_AWS_ROLE_ARN = '<PUT ARN HERE>'
  STORAGE_ALLOWED_LOCATIONS = ('<put here>');

describe INTEGRATION SNOWFLAKE_AWS_ACCESS;
create database RAW_INGEST;
use database RAW_INGEST;
CREATE SCHEMA SCHOOLDB;

use schema RAW_INGEST.SCHOOLDB;

--create file format
CREATE OR REPLACE FILE FORMAT GEN_PARQ
TYPE = PARQUET
COMPRESSION = SNAPPY
NULL_IF = ('MISSING','');

--create stage
create or replace stage SCHOOLDDB_STUDENTS_STAGE
  storage_integration = SNOWFLAKE_AWS_ACCESS
  url = 's3://schooldb/ingest_data/students/'
  file_format = GEN_PARQ;

--create target table with schema variant and ingest record created
CREATE OR REPLACE TABLE STUDENTS_RAW(PARQUET_RAW VARIANT, INTEGRATION_RECORD_CREATED_DT TIMESTAMPLTZ, FILE_NAME VARCHAR(16777216));

-- example copy into from stage
--copy into STUDENTS_RAW from (select $1, current_timestamp() INTEGRATION_TIMESTAMP from @SCHOOLDDB_STUDENTS_STAGE);


-- create pipe
create OR REPLACE pipe raw_ingest.schooldb.STUDENTS_INGEST_PIPE auto_ingest=true as
copy into STUDENTS_RAW from (select $1, current_timestamp() INTEGRATION_TIMESTAMP, METADATA$FILENAME from @SCHOOLDDB_STUDENTS_STAGE);


create or replace role SCHOOLDB_SNOWPIPE;

-- Grant the required privileges on the database objects
grant usage on database RAW_INGEST to role SCHOOLDB_SNOWPIPE;

grant usage on schema RAW_INGEST.SCHOOLDB to role SCHOOLDB_SNOWPIPE;

grant insert, select on RAW_INGEST.SCHOOLDB.STUDENTS_RAW to role SCHOOLDB_SNOWPIPE;

grant usage on stage RAW_INGEST.SCHOOLDB.SCHOOLDDB_STUDENTS_STAGE to role SCHOOLDB_SNOWPIPE;

-- Grant the OWNERSHIP privilege on the pipe object
grant ownership on pipe RAW_INGEST.SCHOOLDB.STUDENTS_INGEST_PIPE to role SCHOOLDB_SNOWPIPE;

-- Grant the role to a user
grant role SCHOOLDB_SNOWPIPE to user WFREEMAN;

SHOW PIPES;

-- handy error checking
WITH CTE AS(
select parse_json(SYSTEM$PIPE_STATUS( 'STUDENTS_INGEST_PIPE' )) AS $1
    )
    SELECT $1:numOutstandingMessagesOnChannel, $1:lastIngestedFilePath, $1:lastReceivedMessageTimestamp, $1:lastForwardedMessageTimestamp FROM CTE;
    
-- handy error checking
SELECT * FROM table(information_schema.copy_history('STUDENTS_RAW',start_time=> dateadd(hours, -1, current_timestamp())));

create or replace TABLE STUDENTS_STG (
	ID NUMBER(38,0),
	FIRST_NAME VARCHAR(16777216),
	LAST_NAME VARCHAR(16777216),
	CREATED_BY VARCHAR(16777216),
	CREATED_ON TIMESTAMP_LTZ(9),
	MODIFIED_BY VARCHAR(16777216),
	MODIFIED_ON TIMESTAMP_LTZ(9),
	RECORD_INTEGRATION_TIMESTAMP TIMESTAMP_LTZ(9),
	ROW_HASH NUMBER(19,0)
);

--create a stream from raw to insert to stage
CREATE OR REPLACE STREAM STUDENTS_RAW_CHANGES ON TABLE STUDENTS_RAW;

--CREATE PROCEDURE TO POPULATE STG_STUDENTS THIS LEVERAGES THE ABOVE STREAM FROM CDC
CREATE OR REPLACE PROCEDURE "APPEND_STUDENTS_STG"()
RETURNS BOOLEAN
LANGUAGE SQL
EXECUTE AS OWNER
AS 'BEGIN 
MERGE INTO RAW_INGEST.SCHOOLDB.STUDENTS_STG TGT USING 
(SELECT
		PARQUET_RAW:id::NUMBER ID,
		PARQUET_RAW:first_name::STRING FIRST_NAME,
		PARQUET_RAW:last_name::STRING LAST_NAME,
		PARQUET_RAW:created_by::STRING CREATED_BY,
		TO_TIMESTAMP(PARQUET_RAW:created_on::NUMBER,
		3) CREATED_ON,
		PARQUET_RAW:modified_by::STRING MODIFIED_BY,
		TO_TIMESTAMP(PARQUET_RAW:modified_on::NUMBER,
		3) MODIFIED_ON,
		INTEGRATION_RECORD_CREATED_DT
FROM
		RAW_INGEST.SCHOOLDB.STUDENTS_RAW_CHANGES
WHERE
		METADATA$ACTION = ''INSERT''
	) SRC
ON TGT.ID = SRC.ID AND TGT.MODIFIED_ON = SRC.MODIFIED_ON
WHEN MATCHED THEN
UPDATE
SET
	TGT.FIRST_NAME = SRC.FIRST_NAME,
	TGT.LAST_NAME = SRC.LAST_NAME,
	TGT.CREATED_BY = SRC.CREATED_BY,
	TGT.CREATED_ON = SRC.CREATED_ON,
	TGT.MODIFIED_BY = SRC.MODIFIED_BY,
	TGT.MODIFIED_ON = SRC.MODIFIED_ON,
	TGT.RECORD_INTEGRATION_TIMESTAMP = SRC.RECORD_INTEGRATION_TIMESTAMP
WHEN NOT MATCHED THEN INSERT (ID, FIRST_NAME, LAST_NAME, CREATED_BY, CREATED_ON, MODIFIED_BY, MODIFIED_ON, RECORD_INTEGRATION_TIMESTAMP) VALUES
(
SRC.ID, SRC.FIRST_NAME, SRC.LAST_NAME , SRC.CREATED_BY, SRC.CREATED_ON, SRC.MODIFIED_BY, SRC.MODIFIED_ON, SRC.INTEGRATION_RECORD_CREATED_DT 
);
RETURN TRUE;
END';


--create a stream from raw to insert to stage
CREATE OR REPLACE STREAM STUDENTS_STG_CHANGES ON TABLE STUDENTS_STG;

--CREATE DIMENSION TABLE FOR STUDENTS
create or replace TABLE STUDENTS_DIM (
	ID NUMBER(38,0),
	FIRST_NAME VARCHAR(16777216),
	LAST_NAME VARCHAR(16777216),
	CREATED_BY VARCHAR(16777216),
	CREATED_ON TIMESTAMP_LTZ(9),
	MODIFIED_BY VARCHAR(16777216),
	MODIFIED_ON TIMESTAMP_LTZ(9),
	RECORD_ACTIVE_FROM_TS TIMESTAMP_LTZ(9),
	RECORD_ACTIVE_TO_TS TIMESTAMP_LTZ(9),
	RECORD_ACTIVE_FLAG VARCHAR(16777216),
    RECORD_MODIFIED_TS TIMESTAMP_LTZ(9)
);
    
CREATE OR REPLACE TASK STUDENT_STG_APPEND
    WAREHOUSE='COMPUTE_WH'
    SCHEDULE='1 MINUTE'
    ALLOW_OVERLAPPING_EXECUTION = FALSE
    WHEN SYSTEM$STREAM_HAS_DATA('STUDENTS_RAW_CHANGES')
    AS
    CALL RAW_INGEST.SCHOOLDB.APPEND_STUDENTS_STG();
    
ALTER TASK STUDENT_STG_APPEND RESUME;

DESCRIBE TASK STUDENT_STG_APPEND;
    
---merge proc to get from stream to dim table
CREATE OR REPLACE PROCEDURE MERGE_STUDENTS_DIM()
RETURNS BOOLEAN
LANGUAGE SQL
EXECUTE AS OWNER
AS BEGIN 
CREATE OR REPLACE TEMPORARY TABLE SOURCE_CHANGES AS (
	WITH SRC_CTE AS (
	SELECT
		SRC.*,
		COALESCE(SRC.MODIFIED_ON, SRC.CREATED_ON) RECORD_ACTIVE_FROM,
		LEAD(SRC.MODIFIED_ON,1,TO_TIMESTAMP_LTZ('2099-12-31T23:59:59.999+08:00')) OVER (PARTITION BY SRC.ID ORDER BY SRC.MODIFIED_ON) RECORD_ACTIVE_TO,
		TO_TIMESTAMP_LTZ(CURRENT_TIMESTAMP) RECORD_MODIFIED,
		RANK() OVER(PARTITION BY SRC.ID ORDER BY SRC.MODIFIED_ON) AS SEQUENCE_RANK
	FROM STUDENTS_STG_CHANGES SRC
		)
	--DO THIS FINAL CTE TO DETERMINE ACTIVE RECORDS
	SELECT 
		SRC.* 
		,CASE WHEN RECORD_ACTIVE_TO >= TO_TIMESTAMP_LTZ('2099-12-31 23:59:59+08:00') THEN 'Y' ELSE 'N' END AS RECORD_ACTIVE_FLAG,
		CASE 
			WHEN TGT.RECORD_HASH IS NULL THEN 'I'
			WHEN SRC.ROW_HASH <> TGT.RECORD_HASH THEN 'U'
		END AS DML_TYPE
	FROM SRC_CTE SRC
	LEFT OUTER JOIN STUDENTS_DIM TGT ON TGT.ID = SRC.ID AND SRC.SEQUENCE_RANK = 1 AND TGT.RECORD_ACTIVE_FLAG = 'Y'
	WHERE (
		SRC.ROW_HASH <> TGT.RECORD_HASH  -- CHANGES
		OR TGT.RECORD_HASH  IS NULL --INSERTS
	) 
);
UPDATE STUDENTS_DIM  AS TGT 
SET
	TGT.RECORD_MODIFIED_TS  = TO_TIMESTAMP_LTZ(CURRENT_TIMESTAMP),
	TGT.RECORD_ACTIVE_TO_TS = SRC.RECORD_ACTIVE_FROM,
	TGT.RECORD_ACTIVE_FLAG = 'N'
	FROM SOURCE_CHANGES SRC 
	WHERE TGT.RECORD_ACTIVE_FLAG = 'Y' 
	AND SRC.DML_TYPE = 'U'
	AND TGT.ID = SRC.ID AND SRC.SEQUENCE_RANK = 1;
	
INSERT
	INTO
	STUDENTS_DIM ( 
	ID,
	FIRST_NAME,
	LAST_NAME,
	CREATED_BY,
	CREATED_ON,
	MODIFIED_BY,
	MODIFIED_ON,
	RECORD_HASH,
	RECORD_ACTIVE_FROM_TS,
	RECORD_ACTIVE_TO_TS,
	RECORD_ACTIVE_FLAG,
	RECORD_MODIFIED_TS
	)
SELECT
	ID,
	FIRST_NAME,
	LAST_NAME,
	CREATED_BY,
	CREATED_ON,
	MODIFIED_BY,
	MODIFIED_ON,
	ROW_HASH,
	RECORD_ACTIVE_FROM,
	RECORD_ACTIVE_TO,
	RECORD_ACTIVE_FLAG,
	RECORD_MODIFIED
FROM
	SOURCE_CHANGES;
RETURN TRUE;
END;

CREATE OR REPLACE TASK STUDENT_DIM_MERGE
WAREHOUSE='COMPUTE_WH'
SCHEDULE='1 MINUTE'
ALLOW_OVERLAPPING_EXECUTION = FALSE
WHEN SYSTEM$STREAM_HAS_DATA('STUDENTS_STG_CHANGES')
AS
CALL RAW_INGEST.SCHOOLDB.MERGE_STUDENTS_DIM();
    
ALTER TASK STUDENT_DIM_MERGE RESUME;
